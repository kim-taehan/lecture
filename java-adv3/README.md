# 김영한의 실전 자바 - 고급 3편, 람다, 스트림, 함수형 프로그래밍

## ch2 람다가 필요한 이유 
### 코드 리펙토링
- 프로그래밍에서 중복을 제거하고, 좋은 코드를 유지하는 방법은 변하는 부분과 변하지 않는 부분을 분리하여 코드를 작성하는 것이다.

### 값 매개변수화
- 문자나 숫자처럼 구체적인 값을 메서드안에 두지 않고 매개변수를 통해 외부에서 전달받도록 해서, 메서드 동작을 달리하고 재사용성을 높이는 방법

### 동작 매개변수화 
- 코드 조각(코드의 동작 방법, 로직, Behavior) 을 메서드(함수) 안에 두는 것이 아니라
  매개변수(파라미터)를 통해서 외부에서 전달 받도록 해서, 메서드의 동작을 달리하고, 재사용성을 높이는 방법을 동작 매개변수화라 한다

```java
public interface Procedure {
    void run();
}

public static void hello(Procedure procedure) {
    long startNs = System.nanoTime();
    //코드 조각 시작
    procedure.run();
    //코드 조각 종료
    long endNs = System.nanoTime();
    System.out.println("실행 시간: " + (endNs - startNs) + "ns");
}

public static void main(String[] args) {
    hello(() -> System.out.println("test"));
}
```


### 함수 VS 메서드
- 함수 
  - 독립적으로 존재하며, 클래스(객체)와 직접적인 연관이 없다
- 메서드 
  - 클래스(또는 객체)에 속해 있는 "함수"이다.
  - 객체의 상태(필드, 프로퍼티 등)에 직접 접근하거나, 객체가 제공해야 할 기능을 구현할 수 있다
 

## ch3 람다 
### 람다 정의 
- 자바 8부터 도입된 람다는 자바에서 함수형 프로그래밍을 지원하기 위한 핵심 기능이다
- **람다는 익명 함수**이다. 따라서 이름 없이 함수를 표현한다
- 람다는 함수형 인터페이스를 구현한 익명 클래스 인스턴스와 같은 개념으로 이해하면 된다.

### 함수형 인터페이스 
- 정확히 하나의 추상 메서드를 가지는 인터페이스라고 한다. 
- 람다는 이러한 함수형 인터페이스에서만 사용할 수 있다. 

### @FunctionalInterface
- 자바에서 제공하는 어노테이션으로 람다를 사용할 인터페이스 생성시 반드시 붙여주자
- SAM 이 아니게 메서드를 붙이려고 하면 컴파일 애러는 발생시킨다.

### 람다의 전달 정리
- 람다는 함수형 인터페이스를 구현한 익명 클래스 인스턴스와 같은 개념으로 이해하면 된다. 
  - 람다를 메서드 매개변수에 전달
  - 람다를 변수에 대입

### 고차 함수
- 고차 함수는 함수를 값처럼 다루는 함수를 뜻한다.
- 일반적으로 다음 두 가지 중 하나를 만족하면 고차 함수라 한다.
  - 함수를 인자로 받는 함수(메서드)
  - 함수를 반환하는 함수(메서드)

###  고차 함수를 구현할 때 자주 등장하는 패턴
- filter : 조건(함수)을 인자로 받아, 리스트에서 필요한 요소만 추려내기
- map : 변환 로직(함수)을 인자로 받아, 리스트의 각 요소를 다른 형태로 바꾸기
- reduce : 누적 로직(함수)을 인자로 받아, 리스트의 모든 요소를 하나의 값으로 축약하기
- 함수를 반환 : 어떤 문자열/정수 등을 받아서, 그에 맞는 새로운 "함수"를 만들어 돌려주기
- 함수 합성 : 두 함수를 이어 붙여, 한 번에 변환 로직을 적용할 수 있는 새 함수를 만들기


## ch4 함수형 인터페이스 
### 자바에서 제공하는 함수형 인터페이스 
| interface           | 메서드 시그니처          | 입력           | 반환           | 사용예시            |
|---------------------|-------------------|--------------|--------------|-----------------|
| Function<T,R>       | R apply(T t)      | 1개           | 1개           | 데이터 변환, 필드 추출 등 |
| Consumer<T>         | void accept<T t)  | 1개           | 없음           | 로그 출력, DB 저장 등  |
| Supplier<T>         | T get()           | 없음           | 1개           | 객체 생성, 값 반환 등   |
| Runnable            | void run()        | 없음           | 없음           | 스레드 실행(멀티스레드)   |
| BiFunction<T, U, R> | R apply(T t, U u)| 2개| 1걔|           데이터 변환, 필드 추출 등      |
| Predicate<T>        | boolean test(T t) | 1개           | boolean      | 조건검사, 필터링       |
| UnaryOperator<T>    | T apply(T t)      | 1개(출력과 동일타입) | 1걔(입력과 동일타입) | 단항 연산           |
| BinaryOperator<T>   | T apply(T t1, T t2)| 2걔(출력과 동일타입)| 1개(입력과 동일타입) | 다항 연산           |



