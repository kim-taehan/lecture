# 오브젝트 - 설계 원칙편

## 섹션 1. 강의 소개
### 1-1. 기능 구현과 설계 원칙
- 설계란? **기능을 구현하는데 적합한 코드의 구조를 결정**
- 프로그램밍의 두가지 관점 
  - 기능: 시스템이 외부에 제공하는 행동
  - 구조: 기능을 구현하기 위한 코드 배치
- 객체지향 시스템 : 메시지를 주고받는 객체들의 협력을 기반으로 기능 구현 
- 객체지향 설계 : 메시지를 주고받는 객체들의 협력을 기반으로 구조 설계
- 좋은 구조를 설계하는 방법은?
  - 책임 주도 설계: 기능을 책임으로 해석해서 객체 협력 설계하기 위한 문맥으로 정의
  - 설계의 핵심은 어떤 객체에게 책임을 할당할 것인가?
  - 처음부터 모든 변경을 수용할 수 있는 안정적인 구조를 설계하는 것이다.
- 설계의 딜레마
  - 동일한 기능을 다양한 방법으로 설계 가능
  - 요구사항 변경 : 현재의 변경에 적합한 설계를 선택해야 한다 (모든 변경을 예상하기는 불가능)
- 리펙토링 (마틴 파울러)
  - 소프트웨어 동작은 유지하고, 코드를 이해하고 수정할 수 있도록 내부의 구조를 변경하는 방법
- 설계원칙 : 다양한 변경에 따라 설계를 **트레이드오프**할 수 있는 기준을 제시

### 1-2. 학습 방법
## 섹션 2. 텍스트 어드벤처 게임
### 2-1. 텍스트 어드벤처 게임
### 2-2. 테스트와 리팩터링
- 리펙터링 : 외부 동작(기능) 변경 없이 내부 설계 개선(구조) 
- 리펙터링 하기 전에 먼저 자체 테스트 코드를 만들어야 한다. 
- 테스트를 자주 실행하고, 컴파일할 때마다 테스트 하고, 적어도 하루에 한번 모든 테스트를 실행
- 설계원칙은 리팩터링의 목표를 제시

#### 안전한 리펙터링을 위한 테스트 
- 테스트 관점에서 객체를 바라봐야 한다. 잘 설계된 객체는 메시지 전송하여 객체의 상태를 변경한다.
- 상태 기반 검증방식의 테스트 
- 상호작용 기반 검증 방식의 테스트

## 섹션 3. 메서드 조합하기 
### 3-1. 단일 추상화 수준 원칙과 조합 메서드
- 메서드 작게 만들기
  - 읽고 이해하기 쉬운 코드
  - 버그수정, 성능 최적화, 메서드 추가용이
  - 작은 메서드에 이름을 통해 주석을 읽는 것 같은 코드 
  - 재사용성 향상, 오버라이딩 용이
- 메서드 추출에서 가장 중요한것
  - 의도를 드러내는 이름 (매커니즘이나 알고리즘은 드러내지 말것)
  - 어떻게 (How)가 아닌 무엇을(What) 을 나타내야 한다.
- 메서드 추출의 이유
  - 가독성 향상
  - 중복 코드 제거
  - 불안정한 의존성 고립: 의존성을 메서드 내부로 제한
- 읽기 쉬운 메서드의 핵심
  - 메서드 안의 모든 코드가 동일한 추상화 수준에 있도록 메서드 추출

#### SLAP (Single Level of Abstraction Principle) 단일 추상화 수준 원칙
- 메서드 내의 모든 코드는 동일한 추상화 수준에 위치해야 한다. 

#### 조합 메서드 패턴 
- 동일한 추상화 수준의 코드를 조합해서 메서드를 만드는 패턴

### 3-2. 조합 메서드로 리팩터링하기
- 동일한 추상화 수준으로 나누기
- 메서드가 오직 한 가지 작업만 수행하게 될 때까지 추출하라.
- 메서드가 오직 한 가지 이유로 변경될 때까지 추출하라. (높은 응집도)

#### 책임의 이동 
- 적절한 기준에 따라 메서드를 클래스로 분배
- 값 객체, 단일 책임 원칙

## 섹션 4. 값 객체와 참조 객체

### 4-1. 참조 객체와 별칭 문제
- 적절한 클래스의 크기는?
- 값 객체, 단일 책임 원칙

#### 참조 객체 
- 모든 클라이언트가 동일한 객체를 이용해서 오퍼레이션을 실행 
- 일반적으로 도메이상의 중요한 개념을 표현 (가변 객체로 구현)
- 값 객체는 값이 변경 되지 않은 작은 객체라고 한다.

### 4-2. 값 객체의 가치
- 값이 동일하면 동일한 객체로 취급
- 값 비교를 통해 참조 객체의 복잡성 감소 
- 불변 객체로 구현
- 상태 추적과 예상하지 못한 부수효과에 대한 사이드 이펙트 줄어듬

#### DRY(Don't Repeat Yourself)
- 모든 지식 조각은 시스템 내에서 하나의 모홓하지 않고 권위있는 표현을 가져야 한다.
### 4-3. 값 객체를 이용해서 Game 개선하기

## 섹션 5. 클래스 나누기
### 5-1. 단일 책임 원칙
#### SRP (단일 책임 원칙)
- 클래스는 단 한 가지 변경 이유만을 가져야 한다.
- 응집도 : 모든 내부 요소들이 함께 변경되는 정도
- 변경의 이유에 따라 클래스를 나눠서 의존하는 객체를 분리
- 결합도 : 외부의 다른 모듈에 의해 함계 변경되는 정도
- 단 하나의 변경 이유만 가질 정도로 클래스는 작아야 한다.

### 5-2. 단일 책임 원칙을 위한 가이드
- 1 책임을 한 문장으로 적어본다 -> 그리고나 또는이 들어가면 여러 책임을 담당하는 클래스이다.
- 2 메서드를 분류한다. -> 이름, 목적이 비슷한 메서드들을 그룹을 묶어보고 이를 클래스로 나눌 수 있을지 확인
- 3 인스턴스 변수와 메서드 사이 관계를 살펴본다. -> 일부 인스턴스 메서드가 일부 메서드에서만 사용
- 4 서로 베타적으로 초기화 되는 인스턴스 변수가 있는지 살펴본다. 
- 5 테스트 하고 싶은 private 메서드가 있는지 살펴본다.
- 6 외부 의존성을 찾는다. -> db, api 호출 등 처럼 외부에 위치하는 불안정한 의존성을 찾는다.

### 5-3. 클래스 나누기
### 5-4.테스트 관점에서 분리하기
### 5-5. 의존성을 기준으로 분리하기

## 섹션 6. 인터페이스 다듬기

### 6-1. 디미터 법칙과 묻지 말고 시켜라 원칙
- Tell, Don't Ask (TDA)
- 디미터 법칙 : 협력하는 객체의 내부구조를 모르고도 협력이 가능해야 함 -
  - 결합도를 낮추기 위해 메시지 전송 대상을 제한
  - 
### 6-2. 명령 쿼리 분리 원칙으로 부수효과 관리하기
- 루틴: 일련의 절차를 묶어 호출 가능하도록 이름을 부여한 기능 모듈
- 프로시져 : 부수효과 존재, 반환 값이 없음 (command)
- 함수 : 부수효과 없음 반환값이 존재 (query)

#### 질문이 답변을 수정해서는 안된다.
- 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다. 
- 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.

## 섹션 7. 테스트와 의존성

### 7-1. 외부 의존성과 테스트

### 7-2. 의존성 역전 원칙 - 상위 수준과 하위 수준
- 상위 수준 모듈은 하위 수준 모듈에 의존해서는 안된다. 둘 모두 추상화에 의존해야 한다.
- 추상화는 세부 사항에 의존해서는 안 된다. 세부 사항이 추상화에 의존해야 한다.

### 7-3. 의존성 역전 원칙 - 추상화와 세부 사항

### 7-4. 의존성 개선하기

### 7-5. 테스트 개선하기

## 섹션 8. 새로운 기능 추가하기

### 8-1. 새로운 요구사항 추가하기
- 새로운 요구 사항 

### 8-2. 전통적인 개방-폐쇄 원칙
#### OCP 개방-폐쇄 원칙
- 모듈이 확장 가능한 경우 개방적이라고 한다. 모듈의 자료 구조에 필드를 추가하거나 수행하는 기능 집합에 새로운 기능을 추가할 수 있어야 한다. 
- 다른 모듈에서 사용할 수 있을 경우 모듈을 폐쇄적이라고 한다. 이 경우 모듈이 잘 정의되고 안정적인 설명을 제공한다는 것을 전제로 한다.

#### 상속의 문제점
- 코드를 재사용하기 위해 상속을 사용하지 마라.


### 8-3. 다형적인 개방-폐쇄 원칙
- 확장에 대해 열려 있다. 
- 수정에 대해 닫혀 있다.
- 안정적인 추상화를 통해 이를 해결한다.
- HAS-A : 합성 관계
- IS-A : 다형성을 사용


### 8-4. 리스코프 치환 원칙

### 8-5. 리스코프 치환 원칙을 위한 가이드
- 구체 메서드를 오버라이딩하지 마라 (super 콜을 피하라)
- 빈 구현으로 오버라이딩하지 마라
- 예외를 던지는 메서드로 오버라이딩하지 마라.
- 정규화된 계층 : 계층 안의 어떤 클래스도 오직 하나의 메서드 구현만 포함 

### 8-6. 아이템 이동 로직 개선하기
 

## 섹션 9. 설계 확장하기

### 9-1. 더 많은 요구사항 추가하기

### 9-2. 인터페이스 분리 원칙
- 클라이어트가 자신이 사용하지 않는 메소드에 의존하도록 강제되어서는 안된다. 
- 클라이언트별로 인터페이스를 분리해서 사용
- 함께 변경되는 클라이언트와 인터페이스가 같은 패키지 포함(단일 책임 원칙)

### 9-3. 인터페이스 분리하기

### 9-4. 책임 정리하기

### 9-5. 실행 환경 확장하기

### 9-6. 중복 코드 제거하기