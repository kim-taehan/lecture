# readable code 

## 추상 
- 중요한 정보는 가려내어 남기고, 덜 중요한 정보는 생략하여 버린다. 
- 적절한 추상화는 복잡한 데이터와 복잡한 로직을 단순화하여 이해하기 쉽도록 돕는다

### 이름짓기
- 단수와 복수를 구분
- 이름 줄이지 않기
- 은어/방언 사용 X
- 좋은 코드를 보고 습득하기

### 메서드와 추상화
- 잘 쓰여진 코드라면, 한 메서드의 주제는 반드시 하나다.
- 메서드의 이름으로 추상화 작업 
- 생략할 정보와 의미를 부여하고 드러낼 정보를 구분하기.
- 의미를 담을 수 있는 더 작은 단위의 메서드로 잘게 쪼개기
- 더 큰 맥락 안에서 포괄적인 의미를 담기 (계층이 생김)

### 메서드 선언부
- 반환타입 메서드명(파라미터) {구현부}
- 메서드 시그니처 (메서드명 + 파라미터) : 오버로딩에서 사용되는 형태 
- 파라미터와 연결지어 더 풍부한 의미를 전달할 수 있다.
- 메서드 시그니처에 납득이 가는, 적절한 타입의 반환값 돌려주기
- void 대신 충분히 반환할 만한 값이 있는지 고민 (테스트 용이)

### 추상화 레벨
- 하나의 세계 안에서는, 추상화 레벨이 동등해야 한다.

### 매직넘버, 매직스트링
- 의미를 갖고 있느나, 상수로 추출되지 않은 숫자, 문자열 등
- 상수 추출로 이름을 짓고 의미를 부여함으로써 가독성, 유지보수성을 높임

## 논리 사고의 흐름
### Early return 
- Early return 으로 else의 사용을 지양

### 사고의 depth 줄이기
- 중첩 분기문, 중첩 반복문
- 사용할 변수는 가깝게 선언하기

#### 주의 사항: 무조건 1depth 로 만들어라가 아니다. 
- 보이는 depth 를 줄이는 것이 아니라 추상화를 통한 사고 과정의 depth 를 줄이는게 중요
- 2중 중첩 구조로 표현하는 것이 사고하는 데에 더 도움이 된다고 판단한다면, 메서드 분리보다 그대로 놔두는 것이 더 나은 선택

### 공백 라인을 대하는 자세
- 공백 라인도 의미를 가진다 : 복잡한 로직의 의미 단위를 나누어 보여줌으로써 추가적인 정보를 전달

### 부정어를 대하는 자세
- 부정어구를 쓰지 않아도 되는 상황인지 체크하기
- 부정의 의미를 담은 다른 단어가 존재하는지 고민하기 or 부정어구로 메서드명 구성 

### 해피 케이스와 예외 처리
- 예외가 발생할 가능성 낮추기
- 어떤 값의 검증이 필요한 부분은 주로 외부 세계와의 접점
  - 사용자 입력, 객체 생성자, 외부 서버의 요청등
- 의도한 예외와 예상하지 못한 예외를 구분
  - 사용자에게 보여줄 예외와, 개발자가 보고 처리해야 할 예외의 구분

#### Null을 대하는 자세
- 항상 NullPointException 을 방지하는 방향으로 경각심 가지기
- 메서드 설계 시 return null 을 자제한다.(Optional)

#### Optional에 관하여
- Optional은 비싼 객체다. 꼭 필요한 상황에서 반환 타입에 사용
- Optional을 파라미터로 받지 않도록 한다. (분기 케이스 3개)
- Optional을 반환받았다면 최대한 빠르게 해소한다.


## 객체

### 객체 설계하기

#### 객체로 추상화
- 비공개 필드(데이터), 비공개 로직(코드)
- 공개 메서드를 선언부를 통해 외부 세계와 소통
- 객체의 책임이 나뉨에 따라 객체 간 협력이 발생


#### 객체가 제공하는 것
- 절차 지향에서 보이지 않았던 개념을 가시화 
- 관심사가 한군데로 모이기 떄문에 유지보수성 높임
- 여러 객체를 사용하는 입장에서는 구현에 신경쓰지 않고 높은 추상화 레벨에서 도메인 로직을 다룰 수 있다.

#### 새로운 객체를 만들 떄 주의할점
- 1개의 관심사로 명확하게 책임이 정의 되었는지 확인
- 생성자, 정적 팩토리 메서드에서 유효성 검증이 가능
- 만약 외부에서 가지고 있는 데이터로 데이터 변경 요청을 해야 하는 경우 set 보다는 update 같이 의도를 드러내는 네이밍 고려
- getter 도 처음에는 사용 자제, 객체에 메시지를 보내라
- 필드의 수는 적을수록 좋다

## 객체 지향 패러다임
### SOLID
- SRP: Single Responsibility Principle
- OCP: Open-Closed Principle
- LSP: Liskov Substitution Principle
- ISP: Interface Segregation Principle
- DIP: Dependency Inversion Principle

### SRP: Single Responsibility Principle (단일 책임 원칙)
- 하나의 클래스는 단 한 가지의 변경 이유만(책임)을 가져야 한다.
- 객체가 가진 공개 메서드, 필드, 상수 등의 해당 객체의 단일 책임에 의해서만 결정
- 관심사 분리
- 높은 응집도, 낮은 결합도

### OCP: Open-CLosed Principle(개방 폐쇄 원칙)
- 확장에는 열려 있고, 수정에는 닫혀 있어야 한다. 
- 기존 코드 변경 없이 시스템의 기능을 확장할 수 있어야 한다. 
- 추상화와 다형성을 활용해서 OCP를 지킬 수 있다. 

### LSP: Liskov Substitution Principle (리스코프 치환 원칙)
- 상속 구조에서, 부모 클래스의 인스턴스를 자식 클래스의 인스턴스로 치환할 수 있어야 한다.
- 자식 클래스는 부모 클래스의 책임을 준수하며, 부모 클래스의 행동을 변경하지 않아야 한다.
- LSP를 위반하면, 상속 클래스를 사용할 때 오동작, 예상 밖의 예외가 발생하거나, 이를 방지하기 위한 불필요한 타입 체크가 동반될 수 있다

### ISP: Interface Segregation Principle (인터페이스 분리 원칙)
- 클라이언트는 자신이 사용하지 않는 인터페이스에 의존하면 안 된다. (인터페이스를 잘게 쪼개라!)
- ISP를 위반하면, 불필요한 의존성으로 인해 결합도가 높아지고, 특정 기능의 변경이 여러 클래스에 영향을 미칠 수 있다


### DIP: Dependency Inversion Principle (의존성 역전 원칙)
- 상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안 된다. 둘 모두 추상화에 의존해야 한다
- 의존성의 순방향 : 고수준 모듈이 저수준 모듈을 참조하는 것
- 의존성의 역방향 : 고수준, 저수준 모듈이 모두 추상화에 의존하는 것
- 저수준 모듈이 변경되어도, 고수준 모듈에는 영향이 가지 않는다.


#### 용어 정리
- DIP (Dependency Inversion Principle) : 고수준 모듈은 저수준 모듈에 의존하면 안된다.
- DI (Dependency Injection) : 의존성 주입 (필요한 의존성을 외부에서 주입)
- IoC (Inversion of Control) : 제어의 역전  

## 객체 지향 적용하기
### 상속과 조합
- 상속보다 조합을 사용하자
- 상속은 시멘트처럼 굳어지는 구조로 수정이 어렵고 (캡슐화), 부모와 자식의 결합도가 높다
- 조합과 인터페이스를 활용하는 것이 유연한 구조
  - 상속을 통한 코드의 중복 제거가 주는 이점보다 유연한 구조 설계과 주는 이점이 크다
  
### Value Object
- 도메인의 어떤 개념을 추상화하여 표현한 값 객체
- 값으로 취급하기 위해서, 불변성, 동등성, 유효성 검증 등을 보장해야 한다

#### VO vs. Entity
- Entity는 식별자가 존재한다. 식별자가 아닌 필드의 값이 달라도, 식별자가 같으면 동등한 객체로 취급한다
  - equals() & hashCode()도 식별자 필드만 가지고 재정의할 수 있다
-  VO는 식별자 없이, 내부의 모든 값이 다 같아야 동등한 객체로 취급한다

### 일급 Collection
- 컬렉션을 포장하면서, 컬렉션만을 유일하게 필드로 가지는 객체 (단 하나의 컬렉션 필드만 가진다)
- 컬렉션을 추상화하며 의미를 담을 수 있고, 가공 로직의 보금자리가 생긴다.
- 만약 getter 로 컬렉션을 반환할 일이 생기면 새로운 컬렉션으로 만들어서 반환하자


#### 일급 시민
- 다른 요소에게 사용 가능한 모든 연산을 지원하는 요소
  - 변수로 할당
  - 파라미터로 전달
  - 함수의 결과로 반환
  
### ENUM
- ENUM 은 상수의 집합으로 상수와 관련된 로직을 담을 수 있는 공간
- 특정 도메인 개념에 대해 그 종류와 기능을 명시적으로 표현
- 만약 변경이 정말 잡은 개념은 enum 보다 db로 관리하는 것이 나을 수 있다.

### 다형성 사용하기
- 변하는 것과 변하지 않는 것을 분리하여 추상화하고, OCP를 지키는 구조

