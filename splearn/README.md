
## 헥사곤을 부르는 여러가 이름 
- 헥사곤
- 애플리케이션
- 앱
- 코어 시스템 
- System under Development
- System under Test

## 액터와 애플리케이션의 상호 작용
- 사용자, 로봇, Test, 다른 시스템 
- 데이터베이스, 클라우드 서비스 존재하는 다른 시스템, 메일 시스템, mock server


## port
- application 이 외부 세계와 의도를 가지고 상호작용 하는 아이디어
- 단순히 데이터를 주고 받는 것이 아니라, 명확한 목적과 방향을 가지고 외부와 연결된다. 
  

## 기능 제공 인터페이스 
- application 이 가지고 있는 기능을 외부 엑터가 사용할수 있게 지원하는 것

## 기능 요구 인터페이스 
- application 이 동작을 하다가 자신이 못하는 기능을 외부 엑터에게 요청하는 것

## 어댑터 (adapter)
- application 의 포트를 엑터가 직접 연결할 . 없다면 인터페이스 변환을 위한 어댑터를 도입
- 브라우저를 통해서 application 의 회원가입 포트의 기능 제공 인터페이스를 사용하려면? 
  - 회원 가입 기능 제공 인터페이스를 사용하는 웹 컨트롤러 어댑터를 만든다. 
- application 이 가진 회원 정보 저장 포트의 기능 요구 인터페이스로 데이터베이스와 직접 연결할 수 없다면?
  - 기능 요구 인터페이스를 구현한 리포지토리 어댑터를 만든다.
- actor - adapter - port - application

## 포트와 어댑터 아키텍터 
- 헥사고날에 아키텍처의 특징을 담은 새로운 이름 

## 오해
### application 내부에 도메인 계층을 만들어야 한다. 
- 헥사고날 아키텍처는 application 내부 구현에 대한 원칙이나 요구사항이 없다.
- 도메인 계층을 포함하는 아키텍처는 클린 아키텍처이다.

### 패키지 구조를 따라야 한다. 
- application과 어댑터 패키지를 분리하는 것은 바람직하다. 
- 포트를 구분된 패키지에 두는 것을 권장한다. 

### 포트는 UseCase 라는 접미사를 사용한다. 
- 포트의 의도를 담은 이름을 사용하면 된다. 
- For+~ing 스타일의 권장 네이밍이 있지만, 이를 따를 필요는 없다.

### application 도메인 모델만 넣고 jpa 엔티티 등은 어댑터에 둬야 한다. 
- application 코드와 포트 인터페이스가 외부 기술에 의존하지 않으면 된다. 

## 사실
### 헥사고날 아키텍처가 요구하는 것
- application은 모든 외부와의 상호 작용을 위해서 provided, required interface 를 정의한다. 
- application과 상호작용 하는 액터는 런타임에서 구성
- application은 액터에 대한 코드 의존성을 가지면 안된다. 
- 액터는 정의된 포트를 통해서만 연결해야 한다. 
- 포트의 인터페이스는 기술 의존성을 가지지 않는다.

## splearn 개발에 적용할 아키텍처 패턴 
- 헥사고날 아키텍처 
- 도메인 모델 패턴 (추천 도서)

## 헥사고날과 도메인 모델 패턴을 적용한 대칭형 계층 구조 
- 도메인계층
- 애플리케이션 계층
- 어댑터 계층
- 외부에서 내부로 향하는 일종의 계층 구조
- 코드의 의존방향은 내부로만 향한다. 
  - 어뎁터 -> 애플리케이션 -> 도메인

### 도메인 주도 개발의 아키텍처 
- 4개의 계층형 아키텍터 : 에릭 에반스 
- 헥사도날 아키텍처 : Vaugn Vernon

## 엔티티 식별자
- 고유성: 두 개의 엔티티가 같은 값을 가지면 안된다.
- 불변성: 한 번 값이 할당되면 엔티티의 생명주기 동안 절대 변경되면 안 된다.
  - 비지니스적인 의미로부터 디커플링 되는 것이 낫다. (자연 키 대신 인조키(대리 키) 사용)

## @Fallback
- spring 최신버전 업데이트 내용 동일한 인터페이스 구현한 빈이 하나도 없을 때만 등록됨

## jpa 와 도메인 모델 패턴

### jpa 모델과 도메인 모델은 다른 것인가?
- 도메인 모델은 데이터베이스와 매핑되는 데이터 모델과 다르며 이를 분리해야 한다. 

### 이런 접근 방법을 선호하는 이유
- 데이터 모델과 도메인 모델이 너무 다른 경우 
  - 레거시 db에 도메인 모델 설계를 적용하는 경우 
- 복잡한 도메인 모델이 데이터 모델과 간단히 매핑되지 않는 경우 
- 데이터 저장 기술이 바뀌는 경우
  - spring data 프로젝트 존재 이유
- 코드에 등장하는 jpa 애노테이션은 기술 의존적이니까

### jpa 기술의 정체성
- orm: 패러다임이 다른 관계형 db와 객체지향 모델의 불일치를 해결하는 기술
  - sql 매핑과는 다른다.(MyBatis)
- jpa의 기술적 목표는 자바 애플리케이션 개발자가 관계형 데이터베이스를 관리하기 위해 자바 도메인 모델을 활용할 
  수 있는 객체/관계 매핑 기능을 제공하는 것 
- jpa의 엔티티는 경량 영속 도메인 오브젝트

### 도메인 모델 패턴
- 단순 도메인 모델은 테이블과 클래스가 1:1로 매핑된다. 
- 복잡한 도메인 모델은 db 매핑이 어렵다는 문제가 있다.
  - 이걸 해결해주는 것이 jpa(orm) 기술
- jpa(orm)이 매핑을 통해서 해결하려는 패러다임 불일치 문제
  - 1 세분성 불일치 
  - 2 상속 불일치
  - 3 정체성 불일치
  - 4 연관 불일치
  - 5 데이터 탐색 불일치

### 스프링 데이터 프로젝트 
- 다양한 데이터 저장소(관계형, 비관계형 데이터베이스) 에 대한 데이터 접근을 단순하고 일관된 프로그래밍 모델로 제공
- 일관된 프로그래밍 모델
- 보일러 플레이트 코드 감소
- 데이터 저장소의 특성 유지
- 확장성과 유연성 
- Repository<T, ID>
  - T:도메인 타입=엔티티=애그리거트 루트

### 도메인 모델과 jpa 모델을 반드시 분리해야 한다는 주장에 대한 반박
- 대부분 데이터 모델과 도메인 모델이 다르지 않음
- 복잡한 도메인 모델의 매핑은 jpa 가 지원
- 모델 변환 로직과 유사한 두 가지 클래스로 인한 불필요한 복잡성 증가
- jpa는 근본적으로 도메인 오브젝트의 매핑을 위해서 설계된 기술
- jpa는 도메인 계층을 침범하지 않음
- 복잡한 쿼리는 커스톰 리포지토리와 어댑터 구현을 통해서 개발 가능 
- 도메인 계층과 데이터 계층의 결합은 불가피하다.